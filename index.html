<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Technique Sharing About Code</title>
  <meta name="author" content="Cui Yongdai">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Technique Sharing About Code"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Technique Sharing About Code" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <meta name="wumiiVerification" content="fb50a101-84fe-4ca2-91a7-ae8cf792978b" />
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <meta name="wumiiVerification" content="d73b5866-c390-4156-a4dd-51b526b5335e" />
</head>

<body>
  <header id="header" class="inner"><div class= "header-content">
	<div class = "alignleft col-one">
		
		<div class="header-div">
		    <h1><a href="/">Technique Sharing About Code</a></h1>
		    <h2><a href="/">Cuiyd&#39;s Blog</a></h2>
		</div>
	</div>
	<div class = "alignright col-two">
		
	</div>
	<div class="clearfix"></div>
</div>

<div class= "header-nav">
	<div id="main-nav" class="alignleft">
	    
	      <a href="/">首页</a>
	    
	      <a href="/archives">归档</a>
	    
	      <a href="/resume">关于我</a>
	    
	</div>
	<div id="sub-nav" class="alignright">
	    
	</div>
	<div class="clearfix"></div>
</div>
</header>
  
      <div id="content" class="inner">
  		<div id="main-col" class="alignleft"><div id="wrapper">
	
    		<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-03-19T05:45:40.000Z"><a href="/2016/03/19/【JVM学习笔记】——GC机制/">2016-03-19</a></time>
        
  
    <h1 class="title"><a href="/2016/03/19/【JVM学习笔记】——GC机制/">【JVM学习笔记】——GC机制</a></h1>
  

    </header>

    <div class="entry">
      
        <div id="toc" class="toc-article">
	<div class="toc-title">目录</div>
	<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#GC机制"><span class="toc-text">GC机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存回收的主要对象"><span class="toc-text">内存回收的主要对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何确定对象已死"><span class="toc-text">如何确定对象已死</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引用计数算法"><span class="toc-text">引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可达性分析算法"><span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一个对象的死亡（真正被回收）至少要经历两次标记"><span class="toc-text">一个对象的死亡（真正被回收）至少要经历两次标记</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#第一次标记"><span class="toc-text">第一次标记</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#finalize方法"><span class="toc-text">finalize方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#第二次标记"><span class="toc-text">第二次标记</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾回收算法"><span class="toc-text">垃圾回收算法</span></a></li></ol></li></ol>
</div>
      
        <h2 id="GC机制"><a href="#GC机制" class="headerlink" title="GC机制"></a><strong>GC机制</strong></h2><h3 id="内存回收的主要对象"><a href="#内存回收的主要对象" class="headerlink" title="内存回收的主要对象"></a><strong>内存回收的主要对象</strong></h3><ul>
<li>我们知道Java运行时数据区域主要分为5部分：程序计数器、虚拟机栈、本地方法栈，以及Java堆、方法区。</li>
<li>由于程序计数器、虚拟机栈、本地方法栈3个区域生命周期依赖于线程，且每一个栈帧分配多少内存基本上在类结构确定下来就已知的，故这些区域的内存分配和回收具备确定性。</li>
<li>而，Java堆和方法区是不确定的，一个接口的多个实现类需要的内存不一样，一个方法中的多个分支需要的内存也不一样，只有在程序运行期间才能知道创建哪些对象，内存分配和回收是动态的。</li>
<li>垃圾收集器GC主要关注的是 —— Java堆和方法区，也是线程共享的区域。<h3 id="如何确定对象已死"><a href="#如何确定对象已死" class="headerlink" title="如何确定对象已死"></a><strong>如何确定对象已死</strong></h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a><strong>引用计数算法</strong></h4>原理：给对象添加一个引用计数器、每当有一个地方引用它的时候，计数器+1；引用失效时，计数器-1；任何时刻计数器为0的对象就不可能再被使用。<br>缺陷：难以解决对象之间相互循环引用的问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#10;&#9;Object o = null;&#10;&#9;public static void testGC()&#123;&#10;&#9;&#9;A a1 = new A();       //a1&#12289;a2&#24341;&#29992;&#35745;&#25968;&#22120;&#22686;&#33267;1&#10;&#9;&#9;A a2 = new A();&#10;&#9;&#9;a1.o = a2;            //a1&#12289;a2&#24341;&#29992;&#35745;&#25968;&#22120;&#22686;&#33267;2&#10;&#9;&#9;a2.o = a1;&#10;&#10;&#9;&#9;a1 = null;           //a1&#12289;a2&#24341;&#29992;&#35745;&#25968;&#22120;&#20943;&#33267;1&#65292;&#20294;&#20004;&#21508;&#39033;&#20173;&#30456;&#20114;&#24341;&#29992;&#10;&#9;&#9;a2 = null;           //&#35299;&#20915;&#26041;&#27861;&#65306;&#20808;&#25191;&#34892;&#35821;&#35328;a1.o=null&#21644;a2.o=null&#65292;&#35753;&#30456;&#20114;&#24341;&#29992;&#22833;&#25928;&#10;&#10;&#9;&#9;System.gc();&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a><strong>可达性分析算法</strong></h4><p>由于引用计数算法的缺陷，主流实现中通过可达性分析（Reachability Analysis）来判断对象的存活。<br>原理：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链（从图论的角度，即不可达），则证明此对象是不可用的。</p>
<p>如下：object5、object6、object7虽然有关联，但到GC Root是不可达的，所以会被定为是可回收的对象。<br><img src="http://img.blog.csdn.net/20160304111636429" alt="可达性分析"><br>在Java语言中，可作为GC Roots的对象：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（Native方法）引用的对象</li>
</ul>
<h4 id="一个对象的死亡（真正被回收）至少要经历两次标记"><a href="#一个对象的死亡（真正被回收）至少要经历两次标记" class="headerlink" title="一个对象的死亡（真正被回收）至少要经历两次标记"></a><strong>一个对象的死亡（真正被回收）至少要经历两次标记</strong></h4><h5 id="第一次标记"><a href="#第一次标记" class="headerlink" title="第一次标记"></a><strong>第一次标记</strong></h5><p>当对象在进行可达性分析后，发现没有到GC Root的引用链，则会发生第一次标记，但并未回收。</p>
<h5 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a><strong>finalize方法</strong></h5><p>发生第一次标记后，GC会对已有一次标记的对象进行第二次筛选：覆盖了finalize()方法且方法未被虚拟机调用的对象将被认为有必要执行finalize()。对象会被放置在一个叫做F-Queue的队列之中，并在稍后一个由虚拟机自动建立的、低优先级的Finalizer线程执行它。<br>在触发了finalize方法后，若方法中能够将对象自身(this)与引用链(Reference Chain)上任何一个对象建立关联，则对象自救成功，第二次标记时，它将被移出“即将回收的集合”。</p>
<h5 id="第二次标记"><a href="#第二次标记" class="headerlink" title="第二次标记"></a><strong>第二次标记</strong></h5><p>在finalize()方法中，对象若无法拯救自己，则GC对它进行第二次标记，这时该对象将要被回收。</p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a><strong>垃圾回收算法</strong></h3><p>经过可达性分析算法确定存活和回收对象后，JVM就会采用垃圾回收算法进行回收，当然不同的虚拟机对回收算法的实现都有不同，这里只是大概总结集中算法的思想。</p>
<ol>
<li><p><strong>标记-清除算法（Mark-Sweep）</strong></p>
<p> 主要分为两个步骤：标记需要回收的对象；完成标记后统一回收被标记的对象。</p>
<p> 缺陷：标记清除后产生大量<strong>不连续的内存碎片</strong>，导致当下一次需要分配较大对象（如数组）时，无法提供足够的连续内存而不得不提取触发一次GC。</p>
</li>
<li><p><strong>复制算法</strong></p>
<p> 这是用于回收新生代的主流算法。基本思想：将内存分成两块A、B，当A内存用完了，将存活的对象复制到B上，再把A用过的内存清理掉，每次只对一块内存进行回收，得到连续内存空间，解决了标记清除算法的缺陷。</p>
<p> 这种算法将内存缩小为原理的一半，代价很高。<strong>故基于新生代中对象“朝生夕死”的特点，将内存分为多个块。</strong>通常的做法是，分成一块较大的Eden空间和两个较小的Survivor空间。每次对Eden和其中一个Survivor空间回收，存活的对象一次性复制到另一个Survivor区中。这样只是浪费了一个小的Survivor区。在进行JVM优化时，可根据实际情况，调整各区域的大小比例。</p>
<p> 那当Survivor空间也不够用怎么办呢？堆内存还有一个年老代（Old Generation），用于提供分配担保（Handle Promotion）。新生代收集下拉的存活对象会直接通过分配担保机制进入年老代。</p>
</li>
<li><p><strong>标记-整理算法（Mark-Compact）</strong></p>
<p> 用于回收年老代。标记完成后，将所有存活的对象向一端移动，然后直接清除其他内存。</p>
</li>
</ol>
<ol>
<li><p><strong>分代收集算法</strong></p>
<p> 针对Java堆中各个年代的特点采用最恰当的收集算法。</p>
<p> 新生代，对象存活率低，采用复制算法，复制成本低。</p>
<p> 年老代，对象存活率高，没有分配担保，必须采用“标记-清除”或“标记整理”算法。</p>
</li>
</ol>

      
    </div>
    <footer>
<!--        -->
        
        
        <div class="alignright">
          <a href="/2016/03/19/【JVM学习笔记】——GC机制/#comment" class="comment-link">Comments</a>
        </div>
        
<!--        -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





    	

	
    		<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-03-19T05:41:43.000Z"><a href="/2016/03/19/【JVM学习笔记】——运行时数据区/">2016-03-19</a></time>
        
  
    <h1 class="title"><a href="/2016/03/19/【JVM学习笔记】——运行时数据区/">【JVM学习笔记】——运行时数据区</a></h1>
  

    </header>

    <div class="entry">
      
        <div id="toc" class="toc-article">
	<div class="toc-title">目录</div>
	<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时数据区域"><span class="toc-text">运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程私有的数据区域"><span class="toc-text">线程私有的数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#程序计数器"><span class="toc-text">程序计数器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#线程恢复"><span class="toc-text">线程恢复</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java虚拟机栈（Java方法执行的内存模型）"><span class="toc-text">Java虚拟机栈（Java方法执行的内存模型）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#局部变量表"><span class="toc-text">局部变量表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#异常状况"><span class="toc-text">异常状况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#本地方法栈"><span class="toc-text">本地方法栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程共享的数据区"><span class="toc-text">线程共享的数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java堆"><span class="toc-text">Java堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法区"><span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#运行时常量池"><span class="toc-text">运行时常量池</span></a></li></ol></li></ol></li></ol></li></ol>
</div>
      
        <p>—— 学习周志明的《understanding the JVM》</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a><strong>运行时数据区域</strong></h2><blockquote>
<p>Java虚拟机在执行程序的过程中，会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，创建及销毁的时间。这些区域的生命周期主要与虚拟机进程和用户线程的启动和结束相关。</p>
</blockquote>
<p>区域划分如下：</p>
<p><img src="http://img.blog.csdn.net/20160302144057265" alt="JVM运行时数据区"></p>
<p><strong>其中方法区和堆是所有线程共享的数据区，另外的就是线程隔离的数据区。</strong></p>
<p>下面一一介绍这些数据区的用途。</p>
<h3 id="线程私有的数据区域"><a href="#线程私有的数据区域" class="headerlink" title="线程私有的数据区域"></a><strong>线程私有的数据区域</strong></h3><blockquote>
<p>1.程序计数器  2.Java虚拟机栈  3.本地方法栈</p>
</blockquote>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h4><p>可以将它理解成当前线程所执行的<strong>字节码指令的行号指示器</strong>（字节码就是Java源程序经编译后生成的文件，Java程序的执行过程实际上是<strong>JVM的字节码解释器执行字节码指令</strong>），在JVM的概念模型里，字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，进而来完成<strong>分支、循环、跳转、异常处理、线程恢复</strong>等基础功能。</p>
<h5 id="线程恢复"><a href="#线程恢复" class="headerlink" title="线程恢复"></a><strong>线程恢复</strong></h5><p>这里再说说是如何实现线程恢复的。首先一个处理器一次只能执行一个线程，要在一个处理器要实现多线程，<strong>JVM是通过线程轮流切换并分配处理器执行时间的方式（操作系统中线程调度算法）</strong>来实现的。<strong>每条线程都有一个独立的程序计数器，且各条线程之间计数器互不影响。</strong>在线程切换的过程中，程序计数器记录下该线程的当前执行位置，当该线程再次被切换时，就可以恢复原来的执行位置了。现在，你也应该理解为什么程序计数器属于线程私有了吧。</p>
<h4 id="Java虚拟机栈（Java方法执行的内存模型）"><a href="#Java虚拟机栈（Java方法执行的内存模型）" class="headerlink" title="Java虚拟机栈（Java方法执行的内存模型）"></a><strong>Java虚拟机栈（Java方法执行的内存模型）</strong></h4><ul>
<li>Java虚拟机栈里面装的是一个个栈帧（Stack Frame）。栈帧存储了局部变量名、操作数栈、动态链接、方法出口等信息。</li>
<li>每个方法执行的时候都会创建一个栈帧。一个方法从调研直至执行完成，对应着一个栈帧在虚拟机栈中入栈和出栈的过程。<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a><strong>局部变量表</strong></h5></li>
<li>有的人Java内存区分为堆内存和栈内存。这是比较粗糙的分法。这里所指的”栈”，就是现在讲的虚拟机栈，再狭窄一点就是虚拟机栈中的局部变量表部分。</li>
<li>局部变量表存放了<strong>编译器</strong>可知的各种基本数据类型、引用类型和returnAddress类型（指向了一条字节码指令的地址）。</li>
<li>局部变量表所需的内存空间在编译期间完成分配，进入一个方法时，栈帧要分配多大的局部变量空间是完全确定的，运行时不会改变。<h5 id="异常状况"><a href="#异常状况" class="headerlink" title="异常状况"></a><strong>异常状况</strong></h5></li>
<li>StackOverflowError：线程请求的栈深度大于虚拟机允许的深度</li>
<li>OutOfMemoryError：虚拟机栈动态扩展时无法申请到足够的内存</li>
</ul>
<p>在JVM规范中，该区域规定了以上两种异常情况，即如果抛出以上异常，则该区域出现了问题。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h4><p>与虚拟机栈相似，只是本地方法栈为虚拟机用到的Native方法服务，而虚拟机栈里面装的是Java方法（字节码）<br>Native方法：用来扩展Java程序的功能，如访问到操作系统底层。可以将native方法比作Java程序和C程序接口，如JNI技术。</p>
<h3 id="线程共享的数据区"><a href="#线程共享的数据区" class="headerlink" title="线程共享的数据区"></a><strong>线程共享的数据区</strong></h3><blockquote>
<p>1.Java堆  2.方法区</p>
</blockquote>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a><strong>Java堆</strong></h4><ul>
<li>随虚拟机启动时创建，为所有<strong>对象实例及数组</strong>分配内存，GC管理的主要区域</li>
<li>区域细分图如下：首先从内存回收的角度，分为Young Generation和Old Generation。Young又细分为Eden Space和Survivor Space。Survivor又分为From Survivor和To Survivor空间。这些区域的作用及分配和回收细节见下文GC机制的讨论。<br><img src="http://img.blog.csdn.net/20160303004105051" alt="Java堆区域结构"><br>从内存分配的角度，线程共享的Java堆可能会划分多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。这样进一步划分，能够更快地分配内存、更好地回收内存。</li>
</ul>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区</strong></h4><ul>
<li>用于存储虚拟机加载的<strong>类信息、常量、静态变量</strong>、即时编译器编译后的代码等数据。</li>
<li>内存回收目标主要是针对常量池的回收和对类型的卸载。</li>
<li>与Java堆相比，这区域可以选择不实现GC，因为一般来说，回收的内存并不多、性价并不高。<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h5></li>
<li>运行时常量池是方法区的一部分</li>
<li>Class文件包含一项信息是常量池（Constant Pool Table），用于存放编译器生成的<strong>各种字面量和符号引用</strong>。（类加载过程中，进入方法区的运行时常量池中存放）</li>
</ul>

      
    </div>
    <footer>
<!--        -->
        
        
        <div class="alignright">
          <a href="/2016/03/19/【JVM学习笔记】——运行时数据区/#comment" class="comment-link">Comments</a>
        </div>
        
<!--        -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





    	

	
    		<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-02-22T14:31:27.000Z"><a href="/2016/02/22/10-skills-for-a-software-developer/">2016-02-22</a></time>
        
  
    <h1 class="title"><a href="/2016/02/22/10-skills-for-a-software-developer/">10 skills for a Java software developer</a></h1>
  

    </header>

    <div class="entry">
      
        <div id="toc" class="toc-article">
	<div class="toc-title">目录</div>
	
</div>
      
        <p>如果你是一个热衷于技术的 Java 程序员， 那么下面的 10 个要点可以让你在众多 Java 开发人员中脱颖而出。</p>
<ol>
<li>拥有扎实的基础和深刻理解 OO 原则</li>
</ol>
<p>对于 Java 程序员，深刻理解 Object Oriented Programming（面向对象编程）这一概念是必须的。没有 OOPS 的坚实基础，就领会不了像 Java 这些面向对象编程语言的美。光学习 OO 原则的定义用处不大，关键是要学会如何应用这些原则用一种 OO 的方式去设计解决方案。因此，我们应该对对象建模、继承、多态、设计模式有一个很好的认识。</p>
<ol>
<li>掌握核心 API</li>
</ol>
<p>如果你不知道语言结构和核心 API，那么即使你在理论知识上再怎么彪悍也是独木难成林。在 Java 中，我们最好能对核心 API，如 java.lang.*、I/O、异常、集合、泛型、线程、JDBC 等有很强的实战经验。要是涉及到 Web 应用的开发，无论你使用的是对 Servlet 有多大关系的框架，JSP 都是必须的。</p>
<ol>
<li>不断编码</li>
</ol>
<p>陆游曾说过，“纸上得来终觉浅，绝知此事要躬行”。从理论上想出一个解决方案很简单，但是真到了实施的时候，才会意识到问题有多难。此时，你才会明白编码过程中存在的语言限制，从而设计出最好的实践方案。因此，请勿中断编码。</p>
<ol>
<li>订阅社区论坛</li>
</ol>
<p>我们并非踽踽独行者。很多人都和我们一样在研究着相同的技术。只是对某个框架概念做验证是不难的，但是当你将这些概念应用到实际的项目中时，那么各 种各样的问题，各种在官方文档上找不到解决方法的难题就会接踵而来。学习新技术首先要做的是订阅相关的技术社区论坛。无论你遇到的是什么问题，总会有人比 你先碰到过，而且搞不好已经找到了解决方法。Ps，还可以解答别人提出来的问题，而且这感觉不要太爽哦。你也可以通过邮件订阅《快乐码农》程序员期刊获取 更多的编程知识，点击订阅。</p>
<ol>
<li>追博客并附上自己的评论</li>
</ol>
<p>正如我前一点所说的，我们并不孤单。成千上万来自世界各地的技术爱好者将他们的技术见解发表在博客上。在博客上我们可以找到很多相同技术的不同观 点。有人会觉得这是一个强大的技术功能，而有的人可能会觉得这是一个愚蠢的框架，仁者见仁智者见智。所以对于同一种技术你会在博客中听到两种不同的声音。 看到好的博客可以写点自己的看法回复在评论上。</p>
<ol>
<li>阅读开源框架的源代码</li>
</ol>
<p>好的开发人员总是知道如何使用框架。但是如果你想成为一个优秀的开发人员，那么你需要研究各种成功和流行的框架源代码，去<strong>了解它的内部工作机制和最佳实践形式</strong>。这是一种高效的使用框架的方法。</p>
<ol>
<li>了解相关技术的发展趋势</li>
</ol>
<p>在开源环境中，软件开发技术总是在不断发展变化。现在所谓的新框架，可能到时候会过时。当前框架上解决不了的问题，可能在新框架上就不再是问题。所以要时刻注意着新事物的诞生和旧事物的消亡。</p>
<ol>
<li><strong>手头准备好常用的代码片段/实用程序</strong></li>
</ol>
<p>有时候我们可能需要一遍又一遍地复制粘贴/编写相同的代码片段/配置。所以，<strong>保存一些配置片段如 log4.properties、jdbc 配置，以及实用程序如 StringUtils、ReflectionUtils、DBUtils</strong> 大有好处。这些东西本身可能并不能让你与众不同，但是你想想看，要是你的合作开发人员希望你帮他从对象集合中获取属性值的列表，而你只需要用 ReflectionUtil 就可以在几分钟内解决，是不是一下子脱颖而出了呢。</p>
<ol>
<li>了解不同的开发方法</li>
</ol>
<p>熟悉不同的开发方法，例如 Agile、SCRUM、XP、Waterfall 等等。现在，选择哪种开发方法是由客户说了算的。有的客户偏好 Agile，而有的则更喜欢 Waterfall 模型。所以对各种方法都能有所涉猎绝对让人刮目相看。</p>
<ol>
<li>将自己对技术的看法记录到文档/博客上</li>
</ol>
<p>在我们每天的工作中，我们或许会学到新的东西，新的做事方法、实践形式和架构理念。可以将这些想法记录到文档或者博客中，分享给大家。因为你现在解决问题的方法可能正是世界上另一个角落另一个开发人员“寻寻觅觅上下求索”的难题，你的分享将完全不亚于一场久旱的甘霖。</p>
<p>via: <a href="http://java.dzone.com/articles/10-things-become-outstanding" target="_blank" rel="external">http://java.dzone.com/articles/10-things-become-outstanding</a></p>

      
    </div>
    <footer>
<!--        -->
        
        
        <div class="alignright">
          <a href="/2016/02/22/10-skills-for-a-software-developer/#comment" class="comment-link">Comments</a>
        </div>
        
<!--        -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





    	

	
    		<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-02-22T09:30:37.000Z"><a href="/2016/02/22/数组的本质/">2016-02-22</a></time>
        
  
    <h1 class="title"><a href="/2016/02/22/数组的本质/">数组的本质（Java）</a></h1>
  

    </header>

    <div class="entry">
      
        <div id="toc" class="toc-article">
	<div class="toc-title">目录</div>
	<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中的数组是对象吗？"><span class="toc-text">Java中的数组是对象吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中数组的类型"><span class="toc-text">Java中数组的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中数组的继承关系"><span class="toc-text">Java中数组的继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中数组的另一种“继承”关系"><span class="toc-text">Java中数组的另一种“继承”关系</span></a></li></ol></li></ol>
</div>
      
        <p>原：<a href="http://blog.csdn.net/zhangjg_blog/article/details/16116613" target="_blank" rel="external">http://blog.csdn.net/zhangjg_blog/article/details/16116613</a></p>
<p>数组是基本上所有语言都会有的一种数据类型，它表示一组相同类型的数据的集合，具有固定的长度，并且在内存中占据连续的空间。在C，C++等语言中，数组的定义简洁清晰，而在java中确有一些会让人迷惑的特性。本文就尝试分析这些特性。</p>
<h2 id="Java中的数组是对象吗？"><a href="#Java中的数组是对象吗？" class="headerlink" title="Java中的数组是对象吗？"></a>Java中的数组是对象吗？</h2><p>Java和C++都是面向对象的语言。在使用这些语言的时候，我们可以直接使用标准的类库，也可以使用组合和继承等面向对象的特性构建自己的类，并且根据自己构建的类创建对象。那么，我们是不是应该考虑这样一个问题：在面向对象的语言中，数组是对象吗？</p>
<p>要判断数组是不是对象，那么首先明确什么是对象，也就是对象的定义。在较高的层面上，对象是根据某个类创建出来的一个实例，表示某类事物中一个具体的个体。对象具有各种属性，并且具有一些特定的行为。而在较低的层面上，站在计算机的角度，对象就是内存中的一个内存块，在这个内存块封装了一些数据，也就是类中定义的各个属性，所以，对象是用来封装数据的。以下为一个Person对象在内存中的表示：<br><img src="http://7xr4wt.com1.z0.glb.clouddn.com/Java-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%AC%E8%B4%A81.png" alt="Java对象在内存中的表示"><br>注意：<br>1）小的红色矩形表示一个引用（地址）或一个基本类型的数据，大的红色矩形表示一个对象，多个小的红色矩形组合在一块，可组成一个对象。<br>2）name在对象中只表示一个引用， 也就是一个地址值，它指向一个真实存在的字符串对象。在这里严格区分了引用和对象。</p>
<p>那么在Java中，数组满足以上的条件吗？在较高的层面上，数组不是某类事物中的一个具体的个体，而是多个个体的集合。那么它应该不是对象。而在计算机的角度，数组也是一个内存块，也封装了一些数据，这样的话也可以称之为对象。以下是一个数组在内存中的表示：<br><img src="http://7xr4wt.com1.z0.glb.clouddn.com/Java-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%AC%E8%B4%A82.png" alt="Java数组在内存中的表示"><br>这样的话， 数组既可以是对象， 也可以不是对象。至于到底是不是把数组当做对象，全凭Java的设计者决定。数组到底是不是对象， 通过代码验证：</p>
<p><pre><code><br>int[] a = new int[4];<br>//a.length;  //对属性的引用不能当成语句<br>int len = a.length;  //数组中保存一个字段, 表示数组的长度<br>//以下方法说明数组可以调用方法,java中的数组是对象.这些方法是Object中的方法,<br>//所以可以肯定,数组的最顶层父类也是Object<br>a.clone();<br>a.toString();<br></code></pre><br>在数组a上， 可以访问他的属性，也可以调用一些方法。<strong>这基本上可以认定，java中的数组也是对象，它具有java中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。</strong></p>
<p>而在C++中，数组虽然封装了数据，但数组名只是一个指针，指向数组中的首个元素，既没有属性，也没有方法可以调用。如下代码所示：</p>
<p><pre><code><br>int main(){<br>    int a[] = {1, 2, 3, 4};<br>    int* pa = a;<br>    //无法访问属性，也不能调用方法。<br>    return 0;<br>}<br></code></pre><br>所以C++中的数组不是对象，只是一个数据的集合，而不能当做对象来使用。</p>
<h2 id="Java中数组的类型"><a href="#Java中数组的类型" class="headerlink" title="Java中数组的类型"></a>Java中数组的类型</h2><p>Java是一种强类型的语言。既然是对象， 那么就必须属于一个类型，比如根据Person类创建一个对象，这个对象的类型就是Person。那么数组的类型是什么呢？看下面的代码：</p>
<p><pre><code><br>int[] a1 = {1, 2, 3, 4};<br>System.out.println(a1.getClass().getName());<br>//打印出的数组类的名字为[I  </code></pre></p>
<p>String[] s = new String[2];<br>System.out.println(s.getClass().getName());<br>//打印出的数组类的名字为  [Ljava.lang.String;  </p>
<p>String[][] ss = new String[2][3];<br>System.out.println(ss.getClass().getName());<br>//打印出的数组类的名字为    [[Ljava.lang.String;  </p>
<p>打印出a1的类型为[ I ，s 的类型是[Ljava.lang.String;  ,  ss的类型是[[Ljava.lang.String;<br><br>所以，<strong>数组也是有类型的</strong>。只是这个类型显得比较奇怪。你可以说a1的类型是int[]，这也无可厚非。但是我们没有自己创建这个类，也没有在Java的标准库中找到这个类。也就是说不管是我们自己的代码，还是在JDK中，都没有如下定义：</p>
<p><pre><code><br>public class int[] {  </code></pre></p>
<pre><code>// ...  

// ...  

// ...  
</code></pre><p>}<br><br>这只能有一个解释，那就是<strong>虚拟机自动创建了数组类型</strong>，可以把数组类型和8种基本数据类型一样， 当做java的内建类型。这种类型的命名规则是这样的：</p>
<ul>
<li>每一维度用一个[表示；开头两个[，就代表是二维数组。</li>
<li>[后面是数组中元素的类型(包括基本数据类型和引用数据类型)</li>
</ul>
<p>在java语言层面上,s是数组,也是一个对象,那么他的类型应该是String[]，这样说是合理的。但是在JVM中，他的类型为[java.lang.String。顺便说一句普通的类在JVM里的类型为 包名+类名，也就是全限定名。同一个类型在java语言中和在虚拟机中的表示可能是不一样的。</p>
<h3 id="Java中数组的继承关系"><a href="#Java中数组的继承关系" class="headerlink" title="Java中数组的继承关系"></a>Java中数组的继承关系</h3><p>上面已经验证了，数组是对象，也就是说可以以操作对象的方式来操作数组。并且数组在虚拟机中有它特别的类型。既然是对象，遵循Java语言中的规则 – Object是上帝， 也就是说所有类的顶层父类都是Object。数组的顶层父类也必须是Object，这就说明数组对象可以向上直接转型到Object，也可以向下强制类型转换，也可以使用instanceof关键字做类型判定。 这一切都和普通对象一样。如下代码所示：</p>
<p><pre><code><br>//1     在test1()中已经测试得到以下结论: 数组也是对象, 数组的顶层父类是Object, 所以可以向上转型<br>int[] a = new int[8];<br>Object obj = a ; //数组的父类也是Object,可以将a向上转型到Object  </code></pre></p>
<p>//2     那么能向下转型吗?<br>int[] b = (int[])obj;  //可以进行向下转型  </p>
<p>//3     能使用instanceof关键字判定吗?<br>if(obj instanceof int[]){  //可以用instanceof关键字进行类型判定<br>    System.out.println(“obj的真实类型是int[]”);<br>}<br></p>
<h3 id="Java中数组的另一种“继承”关系"><a href="#Java中数组的另一种“继承”关系" class="headerlink" title="Java中数组的另一种“继承”关系"></a>Java中数组的另一种“继承”关系</h3><p>如下代码是正确的，却很容易让我们疑惑：</p>
<p><pre><code><br>String[] s = new String[5];<br>Object[] obja = s;   //成立,说明可以用Object[]的引用来接收String[]的对象<br></code></pre><br>Object[]类型的引用可以指向String[]类型的数组对象？ 由上文的验证可以得知数组类型的顶层父类一定是Object，那么上面代码中s的直接父类是谁呢？难道说String[]继承自Object[]，而Object[]又继承自Object? 让我们通过反射的方式来验证这个问题：</p>
<p><pre><code><br>//5     那么String[] 的直接父类是Object[] 还是 Object?<br>System.out.println(s.getClass().getSuperclass().getName());<br>//打印结果为java.lang.Object,说明String[] 的直接父类是 Object而不是Object[]<br></code></pre><br>由代码可知，String[]的直接父类就是Object而不是Object[]。可是Object[]的引用明明可以指向String[]类型的对象。那么他们的继承关系有点像这样：<br><img src="http://7xr4wt.com1.z0.glb.clouddn.com/Java-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%AC%E8%B4%A83.png" alt="继承关系表示"><br>这样的话就违背了Java单继承的原则。String[]不可能即继承Object，又继承Object[]。上面的类图肯定是错误的。那么只能这样解释：数组类直接继承了Object，关于Object[]类型的引用能够指向String[]类型的对象，这种情况只能是Java语法之中的一个特例，并不是严格意义上的继承。也就是说，<strong>String[]不继承自Object[]，但是我可以允许你向上转型到Object[]，这种特性是赋予你的一项特权。</strong></p>
<p>其实这种关系可以这样表述：<strong>如果有两个类A和B，如果B继承（extends）了A，那么A[]类型的引用就可以指向B[]类型的对象。</strong>如下代码所示：</p>
<p><pre><code><br>public static class Father {  </code></pre></p>
<p>}  </p>
<p>public static class Son extends Father {  </p>
<p>}<br>//6   下面成立吗?  Father是Son的直接父类<br>Son[] sons = new Son[3];<br>Father[] fa = sons;  //成立  </p>
<p>//7     那么Son[] 的直接父类是Father[] 还是  Object[] 或者是Object?<br>System.out.println(sons.getClass().getSuperclass().getName());<br>//打印结果为java.lang.Object,说明Son[]的直接父类是Object<br><br>上面的结论可以扩展到二维数组和多维数组：</p>
<p><pre><code><br>Son[][] sonss = new Son[2][4];<br>Father[][] fathers = sonss;<br></code></pre><br>上面的代码可以这样理解：</p>
<p>将Father[][]数组看成是一维数组, 这是个数组中的元素为Father[]，将Son[][]数组看成是一维数组, 这是个数组中的元素为Son[]，因为Father[]类型的引用可以指向Son[]类型的对象，所以，根据上面的结论，Father[][]的引用可以指向Son[][]类型的对象。</p>
<p>数组的这种用法不能作用于基本类型数据：</p>
<p><pre><code><br>int[] aa = new int[4];<br>//Object[] objaa = aa;  //错误的，不能通过编译<br></code></pre><br>这是错误的, 因为int不是引用类型，Object不是int的父类，在这里自动装箱不起作用。但是这种方式是可以的：</p>
<p><pre><code><br>Object[] objss = {“aaa”, 1, 2.5};<br></code></pre><br>这种情况下自动装箱可以工作，也就是说，Object数组中可以存放任何值，包括基本数据类型。</p>
<p>Java为什么会为数组提供这样一种语法特性呢？也就是说这种语法有什么作用？编写过Android中Sqlite数据库操作程序的同学可能发现过这种现象，用一个Object[]引用接收所有的数组对象，在编译SQL语句时，为SQL语句中的占位符提供对应的值。</p>
<p><pre><code><br>db.execSQL(“INSERT INTO person VALUES (NULL, ?, ?)”, new Object[]{person.name, person.age});<br></code></pre><br>所以这种特性主要是用于方法中参数的传递。如果不传递数组，而是依次传递各个值，会使方法参数列表变得冗长。如果使用具体的数组类型，如String[]，那么就限定了类型，失去了灵活性。所以传递数组类型是一种比较好的方式。但是如果没有上面的数组特性（如果有两个类A和B，如果B继承（extends）了A，那么A[]类型的引用就可以指向B[]类型的对象），那么数组类型就只能通过Object类型接收，这样就无法在方法内部访问或遍历数组中的各个元素。如下代码：</p>
<p><pre><code><br>private static void test3() {<br>    String[] a = new String[3];<br>    doArray(a);<br>}  </code></pre></p>
<p>private static void doArray(Object[] objs){  </p>
<p>}  </p>
<p>private static void doArray1(Object obj){<br>    //不能用Object接收数组，因为这样无法对数组的元素进行访问<br>    // obj[1]  //错误  </p>
<pre><code>//如果在方法内部对obj转型到数组，存在类型转换异常的风险  
// Object[] objs = (Object[]) obj;  
</code></pre><p>}  </p>
<p>private static void doArray2(String[] strs){<br>    //如果适用特定类型的数组，就限制了类型，失去灵活性和通用性<br>}  </p>
<p>private static void doArray3(String name, int age, String id, float account){<br>    //如果不适用数组而是依次传递参数，会使参数列表变得冗长，难以阅读<br>}<br><br>到此为止，数组的特性就总结完了。上文中加粗的部分为重要结论。下面贴出整个源码：</p>
<p><pre><code><br>package com.pansoft.zhangjg.testarray;</code></pre></p>
<p>public class ArrayTest {</p>
<pre><code>/**
 * @param args
 */
public static void main(String[] args) {
    test1();
    test2();
    test3();
}

/**
 * 数组具有这种特性：
 * 如果有两个类A和B，如果B继承（extends）了A，那么A[]类型的引用就可以指向B[]类型的对象
 * 测试数组的特殊特性对参数传递的便利性
 */
private static void test3() {
    String[] a = new String[3];
    doArray(a);
}

private static void doArray(Object[] objs){

}

private static void doArray1(Object obj){
    //不能用Object接收数组，因为这样无法对数组的元素进行访问
    // obj[1]  //错误

    //如果在方法内部对obj转型到数组，存在类型转换异常的风险
    // Object[] objs = (Object[]) obj;
}

private static void doArray2(String[] strs){
    //如果适用特定类型的数组，就限制了类型，失去灵活性和通用性
}

private static void doArray3(String name, int age, String id, float account){
    //如果不适用数组而是依次传递参数，会使参数列表变得冗长，难以阅读
}
/**
 * 测试数组的集成关系, 并且他的继承关系是否和数组中元素的类型有关
 */
private static void test2() {

    //1        在test1()中已经测试得到以下结论: 数组也是对象, 数组的顶层父类是Object, 所以可以向上转型
    int[] a = new int[8];
    Object obj = a ; //数组的父类也是Object,可以将a向上转型到Object

    //2        那么能向下转型吗?
    int[] b = (int[])obj;  //可以进行向下转型

    //3        能使用instanceof关键字判定吗?
    if(obj instanceof int[]){  //可以用instanceof关键字进行类型判定
        System.out.println(&quot;obj的真实类型是int[]&quot;);
    }

    //4      下面代码成立吗?
    String[] s = new String[5];
    Object[] obja = s;   //成立,说明可以用Object[]的引用来接收String[]的对象

    //5        那么String[] 的直接父类是Object[] 还是 Object?
    System.out.println(s.getClass().getSuperclass().getName());
    //打印结果为java.lang.Object,说明String[] 的直接父类是 Object而不是Object[]

    //6      下面成立吗?  Father是Son的直接父类
    Son[] sons = new Son[3];
    Father[] fa = sons;  //成立

    //7        那么Son[] 的直接父类是Father[] 还是  Object[] 或者是Object?
    System.out.println(sons.getClass().getSuperclass().getName());
    //打印结果为java.lang.Object,说明Son[]的直接父类是Object

    /**
     * 做一下总结, 如果A是B的父类, 那么A[] 类型的引用可以指向 B[]类型的变量
     * 但是B[]的直接父类是Object, 所有数组的父类都是Object
     */

    //8        上面的结论可以扩展到二维数组
    Son[][] sonss = new Son[2][4];
    Father[][] fathers = sonss;
    //将Father[][]数组看成是一维数组, 这是个数组中的元素为Father[]
    //将Son[][]数组看成是一维数组, 这是个数组中的元素为Son[]
    //因为Father[]类型的引用可以指向Son[]类型的对象
    //所以,根据上面的结论,Father[][]的引用可以指向Son[][]类型的对象

    /**
     * 扩展结论:
     * 因为Object是所有引用类型的父类
     * 所以Object[]的引用可以指向任何引用数据类型的数组的对象. 如:
     * Object[] objs = new String[1];
     * Object[] objs = new Son[1];
     *
     */

    //9        下面的代码成立吗?
    int[] aa = new int[4];
    //Object[] objaa = aa;  //错误的，不能通过编译
    //这是错误的, 因为Object不是int的父类,在这里自动装箱不起作用

    //10     这样可以吗？
    Object[] objss = {&quot;aaa&quot;, 1, 2.5};//成立
}

/**
 * 测试在java语言中,数组是不是对象
 * 如果是对象, 那么他的类型是什么?
 */
private static void test1() {
    int[] a = new int[4];
    //a.length;  //对属性的引用不能当成语句
    int len = a.length;  //数组中保存一个字段, 表示数组的长度

    //以下方法说明数组可以调用方法,java中的数组是对象.这些方法是Object中的方法,所以可以肯定,数组的最顶层父类也是Object
    a.clone();
    a.toString();


    /**
     * java是强类型的语言,一个对象总会有一个特定的类型,例如 Person p = new Person();
     * 对象p(确切的说是引用)的类型是Person类, 这个Person类是我们自己编写的
     * 那么数组的类型是什么呢? 下面使用反射的方式进行验证
     */
    int[] a1 = {1, 2, 3, 4};
    System.out.println(a1.getClass().getName());
    //打印出的数组类的名字为[I

    String[] s = new String[2];
    System.out.println(s.getClass().getName());
    //打印出的数组类的名字为  [Ljava.lang.String;

    String[][] ss = new String[2][3];
    System.out.println(ss.getClass().getName());
    //打印出的数组类的名字为    [[Ljava.lang.String;

    /**
     * 所以,数组也是有类型的,只不过这个类型不是有程序员自己定义的类, 也不是jdk里面
     * 的类, 而是虚拟机在运行时专门创建的类
     * 类型的命名规则是:
     *         每一维度用一个[表示;
     *         [后面是数组中元素的类型(包括基本数据类型和引用数据类型)
     * 
     * 在java语言层面上,s是数组,也是一个对象,那么他的类型应该是String[],
     * 但是在JVM中,他的类型为[java.lang.String
     * 
     * 顺便说一句普通的类在JVM里的类型为 包名+类名, 也就是全限定名
     */
}

public static class Father {

}

public static class Son extends Father {

}
</code></pre><p>}<br></p>

      
    </div>
    <footer>
<!--        -->
        
        
        <div class="alignright">
          <a href="/2016/02/22/数组的本质/#comment" class="comment-link">Comments</a>
        </div>
        
<!--        -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





    	

	
    		<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-02-22T06:49:01.845Z"><a href="/2016/02/22/hello-world/">2016-02-22</a></time>
        
  
    <h1 class="title"><a href="/2016/02/22/hello-world/">Hello World</a></h1>
  

    </header>

    <div class="entry">
      
        <div id="toc" class="toc-article">
	<div class="toc-title">目录</div>
	<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Quick-Start"><span class="toc-text">Quick Start</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Create-a-new-post"><span class="toc-text">Create a new post</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Run-server"><span class="toc-text">Run server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generate-static-files"><span class="toc-text">Generate static files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deploy-to-remote-sites"><span class="toc-text">Deploy to remote sites</span></a></li></ol></li></ol>
</div>
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer>
<!--        -->
        
        
        <div class="alignright">
          <a href="/2016/02/22/hello-world/#comment" class="comment-link">Comments</a>
        </div>
        
<!--        -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





    	

	
    		<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-02-22T06:45:50.000Z"><a href="/2016/02/22/【转帖】IT人为什么难以拿到高薪？/">2016-02-22</a></time>
        
  
    <h1 class="title"><a href="/2016/02/22/【转帖】IT人为什么难以拿到高薪？/">IT人为什么难以拿到高薪</a></h1>
  

    </header>

    <div class="entry">
      
        <div id="toc" class="toc-article">
	<div class="toc-title">目录</div>
	
</div>
      
        <p>最近在论坛里看到很多人发牢骚，说薪水少，可在我看来，你们这样的人拿得到高薪才怪！ </p>
<p>　　我先问一句：这里有多少人是本科的？有多少人是正规本科的（不算自考，成考和专升本）？有多少人是有学位的？有多少有学位的是拿着网大排名前50所大学的学位的？恐怕是少之又少吧！在中国，薪水和学位的关系对于应届生来说是绝对的，即使对于以后的发展，学位也很重要，要不那些低学历的人评职称为什么吃亏呢？你可以告诉我这不合理，不错，这确实不合理，但却是现实。如果你不能改变现实，那还是适应它吧！你也可以告诉我低学历一样可以拿高薪，我承认，不过你要准备比别人多付出10倍以上的努力。</p>
<p>　　接下来是语言，这里恐怕是有不少人没有过四级没学位的吧？有多少过六级的？有多少过专四专八的？有多少有其他英语证书的？你不要和我说你的水平好，可不喜欢中国的考试制度，所以没证书。在中国，毕业一开始的几年就是靠证书，你有本事跳过１楼２楼造３楼吗？如果你英语不行，你有其他二外吗？要知道，老外对于it的重视可是比国内那些买的电脑做装饰品的土老帽要强得多。</p>
<p>　　其实这些都不是最重要的，最重要的做人的风格，现在很多it人除了技术什么都不懂，整天得罪人。哪怕你是四个ccie全考出的，我不用你难道地球就不转了？中国多的是人，技术有什么了不起的？更何况很多技术是根本用不到的。</p>
<p>　　现在总看到一些所谓的“技术牛人”在误导新人，你们知不知道你们是在误人子弟啊！自己混不出头，还要去害别人，今天要和你们好好算算帐。</p>
<p>　　先自我介绍一下，我是98年从上海交大毕业的，在Microsoft（MS）工作了6年，现在在一家系统集成公司工作。</p>
<p>　　第一个意见：<strong>读书最重要，就是为文凭</strong>。我承认大学里确实学不到什么东西，但为了文凭请一定要认真读。这个社会要文凭，没办法。还有大学成绩要读好一些，像ms,cisco,oracle这些大公司是会看的。读大学还有一个好处是大学很空，你可以自己去学想学的东西，不过学校的功课永远是最重要的。那些大专的不要以为本科生学不好技术，确切得说并没有几个优秀的学生是书呆子。没有什么规定说大专生学技术有优势。</p>
<p>　　第二个意见：<strong>好好读英语，要想在it立足，英语是必须的。至少要过六级</strong>，如果能有专八或者中高口证书或者bec什么的就更好，最好还要有二外，可以考虑德语或者日语。作it一定要去外企，国企绝对没前途。</p>
<p>　　第三个意见：要认真选择入的行业。it是非常广泛的概念，网络只是其中一个非常小的（而且也是非常没有前途的）领域。it最有前途的领域是什么？<strong>是开发，开发中最有前途的是什么？是硬件开发，也就是电子工程，那些家伙的月薪差不多是我的年薪（我现在月薪是税后10K）；其次是软件开发，不过很苦，而且需要不错的数学基础，不过在中国不要去搞通用件开发，一盗版全完，最好是搞ERP类的专用系统开发，连开发带维护都有了</strong>。如果你没有数学基础，却有不错的美学功底，那就去搞设计，photoshop也好，autocad也好，3dsmax也好,flash也好，视屏后期处理也好，但不要搞网页设计（无论是前台还是后台），因为一个人作的模扳一万个人用，不会有好的收入的。再不行就来搞网络和系统，这个方面最好搞数据库，不过这样又要涉及到开发，如果搞网络也要搞部署（系统集成），或者去大公司作技术支持，最差的就是作维护了。</p>
<p>　　为什么说维护是最次的？因为无论是什么公司，维护都不是主营业务，或者说，不会为公司带来收入。在公司，能直接影响利润的部门收入才高，所以说任何企业，最重要的是销售和市场，其次是研发和生产，至于我们维护部门，不过是和扫垃圾的和扫厕所的一个级别而已。</p>
<p>　　维护虽然是最差的，但不代表不能拿高薪。首先，要去大的外企，他们对于it部门的重视程度高。第二，要学会为人处世，我们本来就是服务部门，所以对其他部门的人要热情一些，主动一些，不要老摆个“高手”的臭架子。要知道，技术如果不能换钱，那不过是垃圾而已。第三，不要老是问老板要钱换设备，我们已经不能产生利益了，就要让老板感觉我们能节约管理成本，我们的任务是最大限度利用现有的设备，而不是整天采购新的设备。</p>
<p>　　即使如此，我所谓的高薪不过是在维护这个领域里的高薪而已，和其他主要部门是不能比的。所以最好还是跳出这个行业的好，去作系统部署。而作系统部署不要去做部署人员（即使暂时作，将来也一定要做项目经理），这是民工都可以做的。或者就是做方案销售，这样你就是企业的主营业务了。</p>
<p>　　顺便说一下我对认证的看法，相对与学历和英语，它是最不重要的。当年我去ms，靠的不是什么mcse，而是我的专八和名校学历。ms的面试并不关心你的技术，而是关心你是否聪明，是否能溶入企业文化。还有，国内好象很多人对ms不满，因为软件太贵了，这些钱都进了我们这些技术支持的口袋了，不错，ms的员工薪水很高，可这是我们努力工作换来的，我们每天都要工作12小时左右，xp刚发行那段日子xp组的工程师都要工作到凌晨2-3点，白天还是9点上班，难道我们不该拿高薪吗？至于mcse我是进ms后再考的，没有看过书，全是靠<strong>*</strong>过的，也就是你们所说的paper，不过我想说一句，对于应届生，你不用在意自己是不是paper，因为企业已经默认你是paper了，所以无所谓的。</p>
<p>　　总结一下，it界不是没有高薪，而且it的高薪在所有理工类行业中是高的。关键是看你自己的能力。对于还没毕业的同学，我希望你们能先认真读书，<strong>至少拿个学士出来（最好是名校的），然后看看能不能考上好的大学的硕士，同时学好英语，多参加社会活动，即使你作it，技术也不过只有20%的比重而已，重要的是沟通和为人处世的技巧。</strong>对于刚出来的大学生，我的意见是先苦几年，多考一些外语和it的证书，准备向外企跳。</p>
<p>　　最后一句，我所说的也许确实不好听，但事实如此，你可以举很多反例来反驳我（中专生拿高薪之类的），但这些例子是不能反映总体情况的，不信我们可以抽样调查。还有，中国有很多现状是不合理的，但你不能改变它，那要么你适应它，要么你毁灭。在沙漠里谁能活下来？是万物之长的人还是骆驼？（转帖）</p>

      
    </div>
    <footer>
<!--        -->
        
        
        <div class="alignright">
          <a href="/2016/02/22/【转帖】IT人为什么难以拿到高薪？/#comment" class="comment-link">Comments</a>
        </div>
        
<!--        -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





    	

	
    		<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-02-20T12:13:37.000Z"><a href="/2016/02/20/利用Github和Hexo搭建静态博客/">2016-02-20</a></time>
        
  
    <h1 class="title"><a href="/2016/02/20/利用Github和Hexo搭建静态博客/">利用Github和Hexo搭建静态博客</a></h1>
  

    </header>

    <div class="entry">
      
        <div id="toc" class="toc-article">
	<div class="toc-title">目录</div>
	<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#背景"><span class="toc-text">背景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#准备"><span class="toc-text">准备</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#安装Hexo"><span class="toc-text">安装Hexo</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#配置Github"><span class="toc-text">配置Github</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#生成本地的Blog文件夹"><span class="toc-text">生成本地的Blog文件夹</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#部署到Github"><span class="toc-text">部署到Github</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#新建文章和发布"><span class="toc-text">新建文章和发布</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#成功搭建，美化个人博客"><span class="toc-text">成功搭建，美化个人博客</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#更详细的教程"><span class="toc-text">更详细的教程</span></a></li></ol>
</div>
      
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>(1)Hexo是一个开源的静态博客生成框架,由台湾大学生“tommy351”开发，基于NodeJS平台。</p>
<p>(2)静态博客的优缺点：</p>
<blockquote>
<p>优：编译后是纯html页面，支持托管的站点很多，例如github、gitcafe等，提供展示页和域名绑定功能，也是免费使用的，简单易用。</p>
<p>缺：更新文章时，要频繁改动文件，不支持增量式上传的东西，比如ftp，难于管理；还要十分熟悉git各种命令，才能部署页面。</p>
</blockquote>
</blockquote>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><blockquote>
<p>(1)node.js<br>(2)git及github<br>(3)markdown编辑器<br>前两项的安装和github账号的注册，这里就不详述了，网上一大堆教程。<br> markdown编辑器是用来编辑要发布的博文的。所以也要学习一下markdown的基本语法。</p>
</blockquote>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><blockquote>
<p>安装完Node.js和git后（记得两者都要在Path系统环境变量处添加相应的路径，不然安装会失败），输入 <code>npm install -g hexo</code> 指令即可直接安装Hexo。</p>
</blockquote>
<h1 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h1><blockquote>
<p>(1)建立与你用户名对应的仓库，仓库名必须为【<strong>your_user_name.github.io</strong>】，<strong>your_user_name</strong>为你注册的Github账户的用户名。</p>
<p>(2)配置SSH-Key，参考git的使用官方教程。</p>
</blockquote>
<h1 id="生成本地的Blog文件夹"><a href="#生成本地的Blog文件夹" class="headerlink" title="生成本地的Blog文件夹"></a>生成本地的Blog文件夹</h1><blockquote>
<p>(1)在电脑中建立一个名字叫「Hexo」的文件夹（比如我建在了D:\Hexo），然后在此文件夹中右键打开Git Bash。执行下面的命令</p>
<p><pre><code>$ hexo init<br>[info] Copying data<br>[info] You are almost done! Don’t forget to run <code>npm install</code> before you start b<br>logging with Hexo!<br></code></pre></p>
<p>(2)Hexo随后会自动在目标文件夹建立网站所需要的文件。然后按照提示，运行 <code>npm install</code>（在 /D/Hexo下）<code>npm install</code>，会在D:\Hexo目录中安装 node_modules。</p>
</blockquote>
<h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><blockquote>
<p>部署到Github前需要配置_config.yml文件，首先找到下面的内容</p>
<p><pre><code># Deployment<br>## Docs: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">http://hexo.io/docs/deployment.html</a><br>deploy:<br>  type:<br></code></pre><br>然后将它们修改为</p>
<p><pre><code># Deployment<br>## Docs: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">http://hexo.io/docs/deployment.html</a><br>deploy:<br>  type: github<br>  repository: git@github.com:your_user_name/your_user_name.github.io.git<br>  branch: master<br></code></pre><br><strong>NOTE1:</strong></p>
<p>Repository：必须是SSH形式的url（git@github.com:开头），而不能是HTTPS形式的url（<a href="https://github.com/开头），否则会出现错误：" target="_blank" rel="external">https://github.com/开头），否则会出现错误：</a></p>
<p><pre><code>$ hexo deploy<br>[info] Start deploying: github<br>[error] <a href="https://github.com/your_user_name/your_user_name.github.io.git" target="_blank" rel="external">https://github.com/your_user_name/your_user_name.github.io.git</a> is not a valid repositor URL!<br></code></pre><br>因为使用SSH url，如果电脑没有开放SSH 端口，会致部署失败。</p>
<p><pre><code>fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights<br>and the repository exists.<br></code></pre><br>完成到此步，已经搭建好了最基本的个人博客！即便从外网访问 your_user_name.github.io 也能访问到你的个人博客。</p>
</blockquote>
<h1 id="新建文章和发布"><a href="#新建文章和发布" class="headerlink" title="新建文章和发布"></a>新建文章和发布</h1><p><code> hexo new “postName” </code></p>
<blockquote>
<p>#新建文章，随后会看到在D:\Hexo\source目录下</p>
<blockquote>
<p>#生成一个名为postName.md的MarkDown文件。</p>
<blockquote>
<p>#利用MarkDown编辑器编辑博文。</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>hexo generate</code> </p>
<blockquote>
<p>#生成静态页面至public目录</p>
</blockquote>
<p><code>hexo deploy</code> </p>
<blockquote>
<p>#将.deploy目录部署到GitHub。</p>
<blockquote>
<p>#若第6步中repository使用git@github.com:的形式，</p>
<blockquote>
<p>#此处则不必每次deploy都要求输入用户名和密码。</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="成功搭建，美化个人博客"><a href="#成功搭建，美化个人博客" class="headerlink" title="成功搭建，美化个人博客"></a>成功搭建，美化个人博客</h1><blockquote>
<p>利用Hexo的主题功能可以实现更漂亮，功能更多的博客。这里推荐一个Jacman主题。</p>
<p>如何使用 Jacman 主题：<a href="http://wuchong.me/jacman/2014/11/20/how-to-use-jacman/" target="_blank" rel="external">http://wuchong.me/jacman/2014/11/20/how-to-use-jacman/</a></p>
</blockquote>
<h1 id="更详细的教程"><a href="#更详细的教程" class="headerlink" title="更详细的教程"></a>更详细的教程</h1><blockquote>
<p>利用Hexo搭建Github的个人主页：<a href="http://blog.csdn.net/zssureqh/article/details/45921911" target="_blank" rel="external">http://blog.csdn.net/zssureqh/article/details/45921911</a></p>
</blockquote>

      
    </div>
    <footer>
<!--        -->
        
        
        <div class="alignright">
          <a href="/2016/02/20/利用Github和Hexo搭建静态博客/#comment" class="comment-link">Comments</a>
        </div>
        
<!--        -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





    	
 
<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>
</div></div>
  		<aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <h3 class="title" id="categories">分類</h3>
<!--   
	
		<li><a href="/categories/Hexo总结/">Hexo总结</a><small>1</small></li>
	
  
	
		<li><a href="/categories/JVM/">JVM</a><small>1</small></li>
	
  
	
		<li><a href="/categories/Java/">Java</a><small>1</small></li>
	
  
	
		<li><a href="/categories/杂谈/">杂谈</a><small>2</small></li>
	
   -->
     <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo总结/">Hexo总结</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a><span class="category-list-count">2</span></li></ul> 
</div>
 


  
  <div class="widget tag">
    <h3 class="title">归档</h3>
	<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">2016年03月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">2016年02月</a><span class="archive-list-count">5</span></li></ul>
  </div>


  
<div class="widget tagcloud">
  <h3 class="title">標籤雲</h3>
  <div class="entry">
    <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/IT人/" style="font-size: 10px;">IT人</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/教程/" style="font-size: 10px;">教程</a>
  </div>
</div>

</aside>
           <div class="clearfix"></div>
      </div>
  	
   <footer id="footer" class="inner"><div class="alignleft">

  &copy; 2016 Cui Yongdai
  
</div>
<div class="alignright">
  Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme
  <a href="https://github.com/pengloo53/Hexo-theme-light_cn">light_cn</a>
</div>

<div class="visit">
	本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
</div>

<div class="clearfix"></div></footer>
  <script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<!-- 添加『不蒜子』计数服务 -->
<script async src="http://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?dce613887849d114b64d37be797bf201";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>
	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?9acf0cedd48dc53be256ede5a98c2aaa";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>
<!--  -->


</body>
</html>
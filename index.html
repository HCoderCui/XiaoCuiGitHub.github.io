<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Technique Sharing About Code</title>
  <meta name="author" content="Cui Yongdai">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Technique Sharing About Code"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Technique Sharing About Code" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <meta name="wumiiVerification" content="fb50a101-84fe-4ca2-91a7-ae8cf792978b" />
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <meta name="wumiiVerification" content="d73b5866-c390-4156-a4dd-51b526b5335e" />
</head>

<body>
  <header id="header" class="inner"><div class= "header-content">
	<div class = "alignleft col-one">
		
		<div class="header-div">
		    <h1><a href="/">Technique Sharing About Code</a></h1>
		    <h2><a href="/">Cuiyd&#39;s Blog</a></h2>
		</div>
	</div>
	<div class = "alignright col-two">
		
	</div>
	<div class="clearfix"></div>
</div>

<div class= "header-nav">
	<div id="main-nav" class="alignleft">
	    
	      <a href="/">首页</a>
	    
	      <a href="/archives">归档</a>
	    
	      <a href="/resume">关于我</a>
	    
	</div>
	<div id="sub-nav" class="alignright">
	    
	</div>
	<div class="clearfix"></div>
</div>
</header>
  
      <div id="content" class="inner">
  		<div id="main-col" class="alignleft"><div id="wrapper">
	
    		<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-02-22T09:30:37.000Z"><a href="/2016/02/22/数组的本质/">2016-02-22</a></time>
        
  
    <h1 class="title"><a href="/2016/02/22/数组的本质/">数组的本质</a></h1>
  

    </header>

    <div class="entry">
      
        <div id="toc" class="toc-article">
	<div class="toc-title">目录</div>
	<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中的数组是对象吗？"><span class="toc-text">Java中的数组是对象吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中数组的类型"><span class="toc-text">Java中数组的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中数组的继承关系"><span class="toc-text">Java中数组的继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中数组的另一种“继承”关系"><span class="toc-text">Java中数组的另一种“继承”关系</span></a></li></ol></li></ol>
</div>
      
        <p>原：<a href="http://blog.csdn.net/zhangjg_blog/article/details/16116613" target="_blank" rel="external">http://blog.csdn.net/zhangjg_blog/article/details/16116613</a></p>
<p>数组是基本上所有语言都会有的一种数据类型，它表示一组相同类型的数据的集合，具有固定的长度，并且在内存中占据连续的空间。在C，C++等语言中，数组的定义简洁清晰，而在java中确有一些会让人迷惑的特性。本文就尝试分析这些特性。</p>
<h2 id="Java中的数组是对象吗？"><a href="#Java中的数组是对象吗？" class="headerlink" title="Java中的数组是对象吗？"></a>Java中的数组是对象吗？</h2><p>Java和C++都是面向对象的语言。在使用这些语言的时候，我们可以直接使用标准的类库，也可以使用组合和继承等面向对象的特性构建自己的类，并且根据自己构建的类创建对象。那么，我们是不是应该考虑这样一个问题：在面向对象的语言中，数组是对象吗？</p>
<p>要判断数组是不是对象，那么首先明确什么是对象，也就是对象的定义。在较高的层面上，对象是根据某个类创建出来的一个实例，表示某类事物中一个具体的个体。对象具有各种属性，并且具有一些特定的行为。而在较低的层面上，站在计算机的角度，对象就是内存中的一个内存块，在这个内存块封装了一些数据，也就是类中定义的各个属性，所以，对象是用来封装数据的。以下为一个Person对象在内存中的表示：<br><img src="http://7xr4wt.com1.z0.glb.clouddn.com/Java-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%AC%E8%B4%A81.png" alt="Java对象在内存中的表示"><br>注意：<br>1）小的红色矩形表示一个引用（地址）或一个基本类型的数据，大的红色矩形表示一个对象，多个小的红色矩形组合在一块，可组成一个对象。<br>2）name在对象中只表示一个引用， 也就是一个地址值，它指向一个真实存在的字符串对象。在这里严格区分了引用和对象。</p>
<p>那么在Java中，数组满足以上的条件吗？在较高的层面上，数组不是某类事物中的一个具体的个体，而是多个个体的集合。那么它应该不是对象。而在计算机的角度，数组也是一个内存块，也封装了一些数据，这样的话也可以称之为对象。以下是一个数组在内存中的表示：<br><img src="http://7xr4wt.com1.z0.glb.clouddn.com/Java-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%AC%E8%B4%A82.png" alt="Java数组在内存中的表示"><br>这样的话， 数组既可以是对象， 也可以不是对象。至于到底是不是把数组当做对象，全凭Java的设计者决定。数组到底是不是对象， 通过代码验证：</p>
<p><pre><code><br>int[] a = new int[4];<br>//a.length;  //对属性的引用不能当成语句<br>int len = a.length;  //数组中保存一个字段, 表示数组的长度<br>//以下方法说明数组可以调用方法,java中的数组是对象.这些方法是Object中的方法,<br>//所以可以肯定,数组的最顶层父类也是Object<br>a.clone();<br>a.toString();<br></code></pre><br>在数组a上， 可以访问他的属性，也可以调用一些方法。<strong>这基本上可以认定，java中的数组也是对象，它具有java中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。</strong></p>
<p>而在C++中，数组虽然封装了数据，但数组名只是一个指针，指向数组中的首个元素，既没有属性，也没有方法可以调用。如下代码所示：</p>
<p><pre><code><br>int main(){<br>    int a[] = {1, 2, 3, 4};<br>    int* pa = a;<br>    //无法访问属性，也不能调用方法。<br>    return 0;<br>}<br></code></pre><br>所以C++中的数组不是对象，只是一个数据的集合，而不能当做对象来使用。</p>
<h2 id="Java中数组的类型"><a href="#Java中数组的类型" class="headerlink" title="Java中数组的类型"></a>Java中数组的类型</h2><p>Java是一种强类型的语言。既然是对象， 那么就必须属于一个类型，比如根据Person类创建一个对象，这个对象的类型就是Person。那么数组的类型是什么呢？看下面的代码：</p>
<p><pre><code><br>int[] a1 = {1, 2, 3, 4};<br>System.out.println(a1.getClass().getName());<br>//打印出的数组类的名字为[I  </code></pre></p>
<p>String[] s = new String[2];<br>System.out.println(s.getClass().getName());<br>//打印出的数组类的名字为  [Ljava.lang.String;  </p>
<p>String[][] ss = new String[2][3];<br>System.out.println(ss.getClass().getName());<br>//打印出的数组类的名字为    [[Ljava.lang.String;  </p>
<p>打印出a1的类型为[ I ，s 的类型是[Ljava.lang.String;  ,  ss的类型是[[Ljava.lang.String;<br><br>所以，<strong>数组也是有类型的</strong>。只是这个类型显得比较奇怪。你可以说a1的类型是int[]，这也无可厚非。但是我们没有自己创建这个类，也没有在Java的标准库中找到这个类。也就是说不管是我们自己的代码，还是在JDK中，都没有如下定义：</p>
<p><pre><code><br>public class int[] {  </code></pre></p>
<pre><code>// ...  

// ...  

// ...  
</code></pre><p>}<br><br>这只能有一个解释，那就是<strong>虚拟机自动创建了数组类型</strong>，可以把数组类型和8种基本数据类型一样， 当做java的内建类型。这种类型的命名规则是这样的：</p>
<ul>
<li>每一维度用一个[表示；开头两个[，就代表是二维数组。</li>
<li>[后面是数组中元素的类型(包括基本数据类型和引用数据类型)</li>
</ul>
<p>在java语言层面上,s是数组,也是一个对象,那么他的类型应该是String[]，这样说是合理的。但是在JVM中，他的类型为[java.lang.String。顺便说一句普通的类在JVM里的类型为 包名+类名，也就是全限定名。同一个类型在java语言中和在虚拟机中的表示可能是不一样的。</p>
<h3 id="Java中数组的继承关系"><a href="#Java中数组的继承关系" class="headerlink" title="Java中数组的继承关系"></a>Java中数组的继承关系</h3><p>上面已经验证了，数组是对象，也就是说可以以操作对象的方式来操作数组。并且数组在虚拟机中有它特别的类型。既然是对象，遵循Java语言中的规则 – Object是上帝， 也就是说所有类的顶层父类都是Object。数组的顶层父类也必须是Object，这就说明数组对象可以向上直接转型到Object，也可以向下强制类型转换，也可以使用instanceof关键字做类型判定。 这一切都和普通对象一样。如下代码所示：</p>
<p><pre><code><br>//1     在test1()中已经测试得到以下结论: 数组也是对象, 数组的顶层父类是Object, 所以可以向上转型<br>int[] a = new int[8];<br>Object obj = a ; //数组的父类也是Object,可以将a向上转型到Object  </code></pre></p>
<p>//2     那么能向下转型吗?<br>int[] b = (int[])obj;  //可以进行向下转型  </p>
<p>//3     能使用instanceof关键字判定吗?<br>if(obj instanceof int[]){  //可以用instanceof关键字进行类型判定<br>    System.out.println(“obj的真实类型是int[]”);<br>}<br></p>
<h3 id="Java中数组的另一种“继承”关系"><a href="#Java中数组的另一种“继承”关系" class="headerlink" title="Java中数组的另一种“继承”关系"></a>Java中数组的另一种“继承”关系</h3><p>如下代码是正确的，却很容易让我们疑惑：</p>
<p><pre><code><br>String[] s = new String[5];<br>Object[] obja = s;   //成立,说明可以用Object[]的引用来接收String[]的对象<br></code></pre><br>Object[]类型的引用可以指向String[]类型的数组对象？ 由上文的验证可以得知数组类型的顶层父类一定是Object，那么上面代码中s的直接父类是谁呢？难道说String[]继承自Object[]，而Object[]又继承自Object? 让我们通过反射的方式来验证这个问题：</p>
<p><pre><code><br>//5     那么String[] 的直接父类是Object[] 还是 Object?<br>System.out.println(s.getClass().getSuperclass().getName());<br>//打印结果为java.lang.Object,说明String[] 的直接父类是 Object而不是Object[]<br></code></pre><br>由代码可知，String[]的直接父类就是Object而不是Object[]。可是Object[]的引用明明可以指向String[]类型的对象。那么他们的继承关系有点像这样：<br><img src="http://7xr4wt.com1.z0.glb.clouddn.com/Java-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%AC%E8%B4%A83.png" alt="继承关系表示"><br>这样的话就违背了Java单继承的原则。String[]不可能即继承Object，又继承Object[]。上面的类图肯定是错误的。那么只能这样解释：数组类直接继承了Object，关于Object[]类型的引用能够指向String[]类型的对象，这种情况只能是Java语法之中的一个特例，并不是严格意义上的继承。也就是说，<strong>String[]不继承自Object[]，但是我可以允许你向上转型到Object[]，这种特性是赋予你的一项特权。</strong></p>
<p>其实这种关系可以这样表述：<strong>如果有两个类A和B，如果B继承（extends）了A，那么A[]类型的引用就可以指向B[]类型的对象。</strong>如下代码所示：</p>
<p><pre><code><br>public static class Father {  </code></pre></p>
<p>}  </p>
<p>public static class Son extends Father {  </p>
<p>}<br>//6   下面成立吗?  Father是Son的直接父类<br>Son[] sons = new Son[3];<br>Father[] fa = sons;  //成立  </p>
<p>//7     那么Son[] 的直接父类是Father[] 还是  Object[] 或者是Object?<br>System.out.println(sons.getClass().getSuperclass().getName());<br>//打印结果为java.lang.Object,说明Son[]的直接父类是Object<br><br>上面的结论可以扩展到二维数组和多维数组：</p>
<p><pre><code><br>Son[][] sonss = new Son[2][4];<br>Father[][] fathers = sonss;<br></code></pre><br>上面的代码可以这样理解：</p>
<p>将Father[][]数组看成是一维数组, 这是个数组中的元素为Father[]，将Son[][]数组看成是一维数组, 这是个数组中的元素为Son[]，因为Father[]类型的引用可以指向Son[]类型的对象，所以，根据上面的结论，Father[][]的引用可以指向Son[][]类型的对象。</p>
<p>数组的这种用法不能作用于基本类型数据：</p>
<p><pre><code><br>int[] aa = new int[4];<br>//Object[] objaa = aa;  //错误的，不能通过编译<br></code></pre><br>这是错误的, 因为int不是引用类型，Object不是int的父类，在这里自动装箱不起作用。但是这种方式是可以的：</p>
<p><pre><code><br>Object[] objss = {“aaa”, 1, 2.5};<br></code></pre><br>这种情况下自动装箱可以工作，也就是说，Object数组中可以存放任何值，包括基本数据类型。</p>
<p>Java为什么会为数组提供这样一种语法特性呢？也就是说这种语法有什么作用？编写过Android中Sqlite数据库操作程序的同学可能发现过这种现象，用一个Object[]引用接收所有的数组对象，在编译SQL语句时，为SQL语句中的占位符提供对应的值。</p>
<p><pre><code><br>db.execSQL(“INSERT INTO person VALUES (NULL, ?, ?)”, new Object[]{person.name, person.age});<br></code></pre><br>所以这种特性主要是用于方法中参数的传递。如果不传递数组，而是依次传递各个值，会使方法参数列表变得冗长。如果使用具体的数组类型，如String[]，那么就限定了类型，失去了灵活性。所以传递数组类型是一种比较好的方式。但是如果没有上面的数组特性（如果有两个类A和B，如果B继承（extends）了A，那么A[]类型的引用就可以指向B[]类型的对象），那么数组类型就只能通过Object类型接收，这样就无法在方法内部访问或遍历数组中的各个元素。如下代码：</p>
<p><pre><code><br>private static void test3() {<br>    String[] a = new String[3];<br>    doArray(a);<br>}  </code></pre></p>
<p>private static void doArray(Object[] objs){  </p>
<p>}  </p>
<p>private static void doArray1(Object obj){<br>    //不能用Object接收数组，因为这样无法对数组的元素进行访问<br>    // obj[1]  //错误  </p>
<pre><code>//如果在方法内部对obj转型到数组，存在类型转换异常的风险  
// Object[] objs = (Object[]) obj;  
</code></pre><p>}  </p>
<p>private static void doArray2(String[] strs){<br>    //如果适用特定类型的数组，就限制了类型，失去灵活性和通用性<br>}  </p>
<p>private static void doArray3(String name, int age, String id, float account){<br>    //如果不适用数组而是依次传递参数，会使参数列表变得冗长，难以阅读<br>}<br><br>到此为止，数组的特性就总结完了。上文中加粗的部分为重要结论。下面贴出整个源码：</p>
<p><pre><code><br>package com.pansoft.zhangjg.testarray;</code></pre></p>
<p>public class ArrayTest {</p>
<pre><code>/**
 * @param args
 */
public static void main(String[] args) {
    test1();
    test2();
    test3();
}

/**
 * 数组具有这种特性：
 * 如果有两个类A和B，如果B继承（extends）了A，那么A[]类型的引用就可以指向B[]类型的对象
 * 测试数组的特殊特性对参数传递的便利性
 */
private static void test3() {
    String[] a = new String[3];
    doArray(a);
}

private static void doArray(Object[] objs){

}

private static void doArray1(Object obj){
    //不能用Object接收数组，因为这样无法对数组的元素进行访问
    // obj[1]  //错误

    //如果在方法内部对obj转型到数组，存在类型转换异常的风险
    // Object[] objs = (Object[]) obj;
}

private static void doArray2(String[] strs){
    //如果适用特定类型的数组，就限制了类型，失去灵活性和通用性
}

private static void doArray3(String name, int age, String id, float account){
    //如果不适用数组而是依次传递参数，会使参数列表变得冗长，难以阅读
}
/**
 * 测试数组的集成关系, 并且他的继承关系是否和数组中元素的类型有关
 */
private static void test2() {

    //1        在test1()中已经测试得到以下结论: 数组也是对象, 数组的顶层父类是Object, 所以可以向上转型
    int[] a = new int[8];
    Object obj = a ; //数组的父类也是Object,可以将a向上转型到Object

    //2        那么能向下转型吗?
    int[] b = (int[])obj;  //可以进行向下转型

    //3        能使用instanceof关键字判定吗?
    if(obj instanceof int[]){  //可以用instanceof关键字进行类型判定
        System.out.println(&quot;obj的真实类型是int[]&quot;);
    }

    //4      下面代码成立吗?
    String[] s = new String[5];
    Object[] obja = s;   //成立,说明可以用Object[]的引用来接收String[]的对象

    //5        那么String[] 的直接父类是Object[] 还是 Object?
    System.out.println(s.getClass().getSuperclass().getName());
    //打印结果为java.lang.Object,说明String[] 的直接父类是 Object而不是Object[]

    //6      下面成立吗?  Father是Son的直接父类
    Son[] sons = new Son[3];
    Father[] fa = sons;  //成立

    //7        那么Son[] 的直接父类是Father[] 还是  Object[] 或者是Object?
    System.out.println(sons.getClass().getSuperclass().getName());
    //打印结果为java.lang.Object,说明Son[]的直接父类是Object

    /**
     * 做一下总结, 如果A是B的父类, 那么A[] 类型的引用可以指向 B[]类型的变量
     * 但是B[]的直接父类是Object, 所有数组的父类都是Object
     */

    //8        上面的结论可以扩展到二维数组
    Son[][] sonss = new Son[2][4];
    Father[][] fathers = sonss;
    //将Father[][]数组看成是一维数组, 这是个数组中的元素为Father[]
    //将Son[][]数组看成是一维数组, 这是个数组中的元素为Son[]
    //因为Father[]类型的引用可以指向Son[]类型的对象
    //所以,根据上面的结论,Father[][]的引用可以指向Son[][]类型的对象

    /**
     * 扩展结论:
     * 因为Object是所有引用类型的父类
     * 所以Object[]的引用可以指向任何引用数据类型的数组的对象. 如:
     * Object[] objs = new String[1];
     * Object[] objs = new Son[1];
     *
     */

    //9        下面的代码成立吗?
    int[] aa = new int[4];
    //Object[] objaa = aa;  //错误的，不能通过编译
    //这是错误的, 因为Object不是int的父类,在这里自动装箱不起作用

    //10     这样可以吗？
    Object[] objss = {&quot;aaa&quot;, 1, 2.5};//成立
}

/**
 * 测试在java语言中,数组是不是对象
 * 如果是对象, 那么他的类型是什么?
 */
private static void test1() {
    int[] a = new int[4];
    //a.length;  //对属性的引用不能当成语句
    int len = a.length;  //数组中保存一个字段, 表示数组的长度

    //以下方法说明数组可以调用方法,java中的数组是对象.这些方法是Object中的方法,所以可以肯定,数组的最顶层父类也是Object
    a.clone();
    a.toString();


    /**
     * java是强类型的语言,一个对象总会有一个特定的类型,例如 Person p = new Person();
     * 对象p(确切的说是引用)的类型是Person类, 这个Person类是我们自己编写的
     * 那么数组的类型是什么呢? 下面使用反射的方式进行验证
     */
    int[] a1 = {1, 2, 3, 4};
    System.out.println(a1.getClass().getName());
    //打印出的数组类的名字为[I

    String[] s = new String[2];
    System.out.println(s.getClass().getName());
    //打印出的数组类的名字为  [Ljava.lang.String;

    String[][] ss = new String[2][3];
    System.out.println(ss.getClass().getName());
    //打印出的数组类的名字为    [[Ljava.lang.String;

    /**
     * 所以,数组也是有类型的,只不过这个类型不是有程序员自己定义的类, 也不是jdk里面
     * 的类, 而是虚拟机在运行时专门创建的类
     * 类型的命名规则是:
     *         每一维度用一个[表示;
     *         [后面是数组中元素的类型(包括基本数据类型和引用数据类型)
     * 
     * 在java语言层面上,s是数组,也是一个对象,那么他的类型应该是String[],
     * 但是在JVM中,他的类型为[java.lang.String
     * 
     * 顺便说一句普通的类在JVM里的类型为 包名+类名, 也就是全限定名
     */
}

public static class Father {

}

public static class Son extends Father {

}
</code></pre><p>}<br></p>

      
    </div>
    <footer>
<!--        -->
        
        
        <div class="alignright">
          <a href="/2016/02/22/数组的本质/#comment" class="comment-link">Comments</a>
        </div>
        
<!--        -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





    	

	
    		<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-02-22T06:49:01.845Z"><a href="/2016/02/22/hello-world/">2016-02-22</a></time>
        
  
    <h1 class="title"><a href="/2016/02/22/hello-world/">Hello World</a></h1>
  

    </header>

    <div class="entry">
      
        <div id="toc" class="toc-article">
	<div class="toc-title">目录</div>
	<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Quick-Start"><span class="toc-text">Quick Start</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Create-a-new-post"><span class="toc-text">Create a new post</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Run-server"><span class="toc-text">Run server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Generate-static-files"><span class="toc-text">Generate static files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deploy-to-remote-sites"><span class="toc-text">Deploy to remote sites</span></a></li></ol></li></ol>
</div>
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer>
<!--        -->
        
        
        <div class="alignright">
          <a href="/2016/02/22/hello-world/#comment" class="comment-link">Comments</a>
        </div>
        
<!--        -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





    	

	
    		<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-02-22T06:45:50.000Z"><a href="/2016/02/22/【转帖】IT人为什么难以拿到高薪？/">2016-02-22</a></time>
        
  
    <h1 class="title"><a href="/2016/02/22/【转帖】IT人为什么难以拿到高薪？/">IT人为什么难以拿到高薪</a></h1>
  

    </header>

    <div class="entry">
      
        <div id="toc" class="toc-article">
	<div class="toc-title">目录</div>
	
</div>
      
        <p>最近在论坛里看到很多人发牢骚，说薪水少，可在我看来，你们这样的人拿得到高薪才怪！ </p>
<p>　　我先问一句：这里有多少人是本科的？有多少人是正规本科的（不算自考，成考和专升本）？有多少人是有学位的？有多少有学位的是拿着网大排名前50所大学的学位的？恐怕是少之又少吧！在中国，薪水和学位的关系对于应届生来说是绝对的，即使对于以后的发展，学位也很重要，要不那些低学历的人评职称为什么吃亏呢？你可以告诉我这不合理，不错，这确实不合理，但却是现实。如果你不能改变现实，那还是适应它吧！你也可以告诉我低学历一样可以拿高薪，我承认，不过你要准备比别人多付出10倍以上的努力。</p>
<p>　　接下来是语言，这里恐怕是有不少人没有过四级没学位的吧？有多少过六级的？有多少过专四专八的？有多少有其他英语证书的？你不要和我说你的水平好，可不喜欢中国的考试制度，所以没证书。在中国，毕业一开始的几年就是靠证书，你有本事跳过１楼２楼造３楼吗？如果你英语不行，你有其他二外吗？要知道，老外对于it的重视可是比国内那些买的电脑做装饰品的土老帽要强得多。</p>
<p>　　其实这些都不是最重要的，最重要的做人的风格，现在很多it人除了技术什么都不懂，整天得罪人。哪怕你是四个ccie全考出的，我不用你难道地球就不转了？中国多的是人，技术有什么了不起的？更何况很多技术是根本用不到的。</p>
<p>　　现在总看到一些所谓的“技术牛人”在误导新人，你们知不知道你们是在误人子弟啊！自己混不出头，还要去害别人，今天要和你们好好算算帐。</p>
<p>　　先自我介绍一下，我是98年从上海交大毕业的，在Microsoft（MS）工作了6年，现在在一家系统集成公司工作。</p>
<p>　　第一个意见：<strong>读书最重要，就是为文凭</strong>。我承认大学里确实学不到什么东西，但为了文凭请一定要认真读。这个社会要文凭，没办法。还有大学成绩要读好一些，像ms,cisco,oracle这些大公司是会看的。读大学还有一个好处是大学很空，你可以自己去学想学的东西，不过学校的功课永远是最重要的。那些大专的不要以为本科生学不好技术，确切得说并没有几个优秀的学生是书呆子。没有什么规定说大专生学技术有优势。</p>
<p>　　第二个意见：<strong>好好读英语，要想在it立足，英语是必须的。至少要过六级</strong>，如果能有专八或者中高口证书或者bec什么的就更好，最好还要有二外，可以考虑德语或者日语。作it一定要去外企，国企绝对没前途。</p>
<p>　　第三个意见：要认真选择入的行业。it是非常广泛的概念，网络只是其中一个非常小的（而且也是非常没有前途的）领域。it最有前途的领域是什么？<strong>是开发，开发中最有前途的是什么？是硬件开发，也就是电子工程，那些家伙的月薪差不多是我的年薪（我现在月薪是税后10K）；其次是软件开发，不过很苦，而且需要不错的数学基础，不过在中国不要去搞通用件开发，一盗版全完，最好是搞ERP类的专用系统开发，连开发带维护都有了</strong>。如果你没有数学基础，却有不错的美学功底，那就去搞设计，photoshop也好，autocad也好，3dsmax也好,flash也好，视屏后期处理也好，但不要搞网页设计（无论是前台还是后台），因为一个人作的模扳一万个人用，不会有好的收入的。再不行就来搞网络和系统，这个方面最好搞数据库，不过这样又要涉及到开发，如果搞网络也要搞部署（系统集成），或者去大公司作技术支持，最差的就是作维护了。</p>
<p>　　为什么说维护是最次的？因为无论是什么公司，维护都不是主营业务，或者说，不会为公司带来收入。在公司，能直接影响利润的部门收入才高，所以说任何企业，最重要的是销售和市场，其次是研发和生产，至于我们维护部门，不过是和扫垃圾的和扫厕所的一个级别而已。</p>
<p>　　维护虽然是最差的，但不代表不能拿高薪。首先，要去大的外企，他们对于it部门的重视程度高。第二，要学会为人处世，我们本来就是服务部门，所以对其他部门的人要热情一些，主动一些，不要老摆个“高手”的臭架子。要知道，技术如果不能换钱，那不过是垃圾而已。第三，不要老是问老板要钱换设备，我们已经不能产生利益了，就要让老板感觉我们能节约管理成本，我们的任务是最大限度利用现有的设备，而不是整天采购新的设备。</p>
<p>　　即使如此，我所谓的高薪不过是在维护这个领域里的高薪而已，和其他主要部门是不能比的。所以最好还是跳出这个行业的好，去作系统部署。而作系统部署不要去做部署人员（即使暂时作，将来也一定要做项目经理），这是民工都可以做的。或者就是做方案销售，这样你就是企业的主营业务了。</p>
<p>　　顺便说一下我对认证的看法，相对与学历和英语，它是最不重要的。当年我去ms，靠的不是什么mcse，而是我的专八和名校学历。ms的面试并不关心你的技术，而是关心你是否聪明，是否能溶入企业文化。还有，国内好象很多人对ms不满，因为软件太贵了，这些钱都进了我们这些技术支持的口袋了，不错，ms的员工薪水很高，可这是我们努力工作换来的，我们每天都要工作12小时左右，xp刚发行那段日子xp组的工程师都要工作到凌晨2-3点，白天还是9点上班，难道我们不该拿高薪吗？至于mcse我是进ms后再考的，没有看过书，全是靠<strong>*</strong>过的，也就是你们所说的paper，不过我想说一句，对于应届生，你不用在意自己是不是paper，因为企业已经默认你是paper了，所以无所谓的。</p>
<p>　　总结一下，it界不是没有高薪，而且it的高薪在所有理工类行业中是高的。关键是看你自己的能力。对于还没毕业的同学，我希望你们能先认真读书，<strong>至少拿个学士出来（最好是名校的），然后看看能不能考上好的大学的硕士，同时学好英语，多参加社会活动，即使你作it，技术也不过只有20%的比重而已，重要的是沟通和为人处世的技巧。</strong>对于刚出来的大学生，我的意见是先苦几年，多考一些外语和it的证书，准备向外企跳。</p>
<p>　　最后一句，我所说的也许确实不好听，但事实如此，你可以举很多反例来反驳我（中专生拿高薪之类的），但这些例子是不能反映总体情况的，不信我们可以抽样调查。还有，中国有很多现状是不合理的，但你不能改变它，那要么你适应它，要么你毁灭。在沙漠里谁能活下来？是万物之长的人还是骆驼？（转帖）</p>

      
    </div>
    <footer>
<!--        -->
        
        
        <div class="alignright">
          <a href="/2016/02/22/【转帖】IT人为什么难以拿到高薪？/#comment" class="comment-link">Comments</a>
        </div>
        
<!--        -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





    	

	
    		<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-02-20T12:13:37.000Z"><a href="/2016/02/20/利用Github和Hexo搭建静态博客/">2016-02-20</a></time>
        
  
    <h1 class="title"><a href="/2016/02/20/利用Github和Hexo搭建静态博客/">利用Github和Hexo搭建静态博客</a></h1>
  

    </header>

    <div class="entry">
      
        <div id="toc" class="toc-article">
	<div class="toc-title">目录</div>
	<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#背景"><span class="toc-text">背景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#准备"><span class="toc-text">准备</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#安装Hexo"><span class="toc-text">安装Hexo</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#配置Github"><span class="toc-text">配置Github</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#生成本地的Blog文件夹"><span class="toc-text">生成本地的Blog文件夹</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#部署到Github"><span class="toc-text">部署到Github</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#新建文章和发布"><span class="toc-text">新建文章和发布</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#成功搭建，美化个人博客"><span class="toc-text">成功搭建，美化个人博客</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#更详细的教程"><span class="toc-text">更详细的教程</span></a></li></ol>
</div>
      
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>(1)Hexo是一个开源的静态博客生成框架,由台湾大学生“tommy351”开发，基于NodeJS平台。</p>
<p>(2)静态博客的优缺点：</p>
<blockquote>
<p>优：编译后是纯html页面，支持托管的站点很多，例如github、gitcafe等，提供展示页和域名绑定功能，也是免费使用的，简单易用。</p>
<p>缺：更新文章时，要频繁改动文件，不支持增量式上传的东西，比如ftp，难于管理；还要十分熟悉git各种命令，才能部署页面。</p>
</blockquote>
</blockquote>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><blockquote>
<p>(1)node.js<br>(2)git及github<br>(3)markdown编辑器<br>前两项的安装和github账号的注册，这里就不详述了，网上一大堆教程。<br> markdown编辑器是用来编辑要发布的博文的。所以也要学习一下markdown的基本语法。</p>
</blockquote>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><blockquote>
<p>安装完Node.js和git后（记得两者都要在Path系统环境变量处添加相应的路径，不然安装会失败），输入 <code>npm install -g hexo</code> 指令即可直接安装Hexo。</p>
</blockquote>
<h1 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h1><blockquote>
<p>(1)建立与你用户名对应的仓库，仓库名必须为【<strong>your_user_name.github.io</strong>】，<strong>your_user_name</strong>为你注册的Github账户的用户名。</p>
<p>(2)配置SSH-Key，参考git的使用官方教程。</p>
</blockquote>
<h1 id="生成本地的Blog文件夹"><a href="#生成本地的Blog文件夹" class="headerlink" title="生成本地的Blog文件夹"></a>生成本地的Blog文件夹</h1><blockquote>
<p>(1)在电脑中建立一个名字叫「Hexo」的文件夹（比如我建在了D:\Hexo），然后在此文件夹中右键打开Git Bash。执行下面的命令</p>
<p><pre><code>$ hexo init<br>[info] Copying data<br>[info] You are almost done! Don’t forget to run <code>npm install</code> before you start b<br>logging with Hexo!<br></code></pre></p>
<p>(2)Hexo随后会自动在目标文件夹建立网站所需要的文件。然后按照提示，运行 <code>npm install</code>（在 /D/Hexo下）<code>npm install</code>，会在D:\Hexo目录中安装 node_modules。</p>
</blockquote>
<h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><blockquote>
<p>部署到Github前需要配置_config.yml文件，首先找到下面的内容</p>
<p><pre><code># Deployment<br>## Docs: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">http://hexo.io/docs/deployment.html</a><br>deploy:<br>  type:<br></code></pre><br>然后将它们修改为</p>
<p><pre><code># Deployment<br>## Docs: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">http://hexo.io/docs/deployment.html</a><br>deploy:<br>  type: github<br>  repository: git@github.com:your_user_name/your_user_name.github.io.git<br>  branch: master<br></code></pre><br><strong>NOTE1:</strong></p>
<p>Repository：必须是SSH形式的url（git@github.com:开头），而不能是HTTPS形式的url（<a href="https://github.com/开头），否则会出现错误：" target="_blank" rel="external">https://github.com/开头），否则会出现错误：</a></p>
<p><pre><code>$ hexo deploy<br>[info] Start deploying: github<br>[error] <a href="https://github.com/your_user_name/your_user_name.github.io.git" target="_blank" rel="external">https://github.com/your_user_name/your_user_name.github.io.git</a> is not a valid repositor URL!<br></code></pre><br>因为使用SSH url，如果电脑没有开放SSH 端口，会致部署失败。</p>
<p><pre><code>fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights<br>and the repository exists.<br></code></pre><br>完成到此步，已经搭建好了最基本的个人博客！即便从外网访问 your_user_name.github.io 也能访问到你的个人博客。</p>
</blockquote>
<h1 id="新建文章和发布"><a href="#新建文章和发布" class="headerlink" title="新建文章和发布"></a>新建文章和发布</h1><p><code> hexo new “postName” </code></p>
<blockquote>
<p>#新建文章，随后会看到在D:\Hexo\source目录下</p>
<blockquote>
<p>#生成一个名为postName.md的MarkDown文件。</p>
<blockquote>
<p>#利用MarkDown编辑器编辑博文。</p>
</blockquote>
</blockquote>
</blockquote>
<p><code>hexo generate</code> </p>
<blockquote>
<p>#生成静态页面至public目录</p>
</blockquote>
<p><code>hexo deploy</code> </p>
<blockquote>
<p>#将.deploy目录部署到GitHub。</p>
<blockquote>
<p>#若第6步中repository使用git@github.com:的形式，</p>
<blockquote>
<p>#此处则不必每次deploy都要求输入用户名和密码。</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="成功搭建，美化个人博客"><a href="#成功搭建，美化个人博客" class="headerlink" title="成功搭建，美化个人博客"></a>成功搭建，美化个人博客</h1><blockquote>
<p>利用Hexo的主题功能可以实现更漂亮，功能更多的博客。这里推荐一个Jacman主题。</p>
<p>如何使用 Jacman 主题：<a href="http://wuchong.me/jacman/2014/11/20/how-to-use-jacman/" target="_blank" rel="external">http://wuchong.me/jacman/2014/11/20/how-to-use-jacman/</a></p>
</blockquote>
<h1 id="更详细的教程"><a href="#更详细的教程" class="headerlink" title="更详细的教程"></a>更详细的教程</h1><blockquote>
<p>利用Hexo搭建Github的个人主页：<a href="http://blog.csdn.net/zssureqh/article/details/45921911" target="_blank" rel="external">http://blog.csdn.net/zssureqh/article/details/45921911</a></p>
</blockquote>

      
    </div>
    <footer>
<!--        -->
        
        
        <div class="alignright">
          <a href="/2016/02/20/利用Github和Hexo搭建静态博客/#comment" class="comment-link">Comments</a>
        </div>
        
<!--        -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





    	
 
<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>
</div></div>
  		<aside id="sidebar" class="alignright">
  
<div class="widget tag">
  <h3 class="title" id="categories">分類</h3>
<!--   
	
		<li><a href="/categories/Hexo总结/">Hexo总结</a><small>1</small></li>
	
  
	
		<li><a href="/categories/Java/">Java</a><small>1</small></li>
	
  
	
		<li><a href="/categories/杂谈/">杂谈</a><small>1</small></li>
	
   -->
     <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo总结/">Hexo总结</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a><span class="category-list-count">1</span></li></ul> 
</div>
 


  
  <div class="widget tag">
    <h3 class="title">归档</h3>
	<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">2016年02月</a><span class="archive-list-count">4</span></li></ul>
  </div>


  
<div class="widget tagcloud">
  <h3 class="title">標籤雲</h3>
  <div class="entry">
    <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/IT人/" style="font-size: 10px;">IT人</a> <a href="/tags/教程/" style="font-size: 10px;">教程</a>
  </div>
</div>

</aside>
           <div class="clearfix"></div>
      </div>
  	
   <footer id="footer" class="inner"><div class="alignleft">

  &copy; 2016 Cui Yongdai
  
</div>
<div class="alignright">
  Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme
  <a href="https://github.com/pengloo53/Hexo-theme-light_cn">light_cn</a>
</div>

<div class="visit">
	本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
</div>

<div class="clearfix"></div></footer>
  <script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<!-- 添加『不蒜子』计数服务 -->
<script async src="http://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?dce613887849d114b64d37be797bf201";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>
	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?9acf0cedd48dc53be256ede5a98c2aaa";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>
<!--  -->


</body>
</html>